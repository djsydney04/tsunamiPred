import torch
import torch.nn as nn
import torch.optim as optim
import random 

import pandas as pd

import numpy as np

import matplotlib.pyplot as plt

from models.seismic_model import SeismicTsunamiEventLinkageModel
from utils.preprocess import preprocess

#setting random seed
torch.manual_seed(42)
np.random.seed(42)
random.seed(42)

#loading data
x_train, x_test, y_train, y_test = preprocess()

#creating model
model = SeismicTsunamiEventLinkageModel(input_size=10, hidden_size=128, hidden_size2=64, hidden_size3=32, output_size=1)

#defining loss function
loss_function = nn.BCELoss()

#defining optimizer
optimizer = optim.Adam(model.parameters(), lr=0.001)

#defining number of epochs
num_epochs = 10000
user_patience =input("Enter the patience value: ")
print("Training model...")

# Early stopping class stays the same
class EarlyStopping:
    def __init__(self, patience=10):
        self.patience = patience
        self.best_loss = float('inf')
        self.best_model_state = None
        self.patience_counter = 0
    def check_loss(self, loss, model):
        if loss.item() < self.best_loss:
            self.best_loss = loss.item()
            self.best_model_state = model.state_dict().copy()
            self.patience_counter = 0
        else:
            self.patience_counter += 1
            if self.patience_counter >= self.patience:
                return True  # Should stop
        return False  # Should continue

trainer = EarlyStopping(patience=int(user_patience))
# Training loop
early_stopped = False  # Flag to track if we stopped early
for epoch in range(num_epochs):
    optimizer.zero_grad()
    # Forward pass
    predictions = model(x_train)
    # Calculate loss
    loss = loss_function(predictions, y_train)
    # Backward pass
    loss.backward()
    # Optimizer step
    optimizer.step()
    
    # Print progress
    if epoch % 100 == 0:
        print(f"Epoch {epoch+1}, Loss: {loss.item():.4f}")
    
    # Early stopping check
    if trainer.check_loss(loss, model):
        print(f"\nEarly stopping triggered at epoch {epoch+1}")
        print(f"No improvement for {trainer.patience} epochs")
        print(f"Best loss was: {trainer.best_loss:.4f}")
        early_stopped = True
        break

# Save the best model and print final message
torch.save(trainer.best_model_state, "models/tsunami_model.pth")
if early_stopped:
    print(f"\nTraining stopped early. Best model saved with loss: {trainer.best_loss:.4f}")
else:
    print(f"\nTraining completed all {num_epochs} epochs. Best model saved with loss: {trainer.best_loss:.4f}")